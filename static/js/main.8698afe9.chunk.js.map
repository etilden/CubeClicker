{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","clickLocator","event","state","cubes","filter","cube","cubeIncludes","pageX","pageY","clickedCube","directionChanger","lost","console","log","clickX","clickY","position","x","cubeX","cubeY","y","window","innerHeight","xDifferentiation","Math","random","yDifferentiation","bind","document","addEventListener","scene","THREE","camera","innerWidth","set","lookAt","renderer","setSize","body","appendChild","domElement","geometry","z","light","makeInstance","color","name","material","add","this","setState","animate","requestAnimationFrame","forEach","i","additional","rotation","render","travel","setClearColor","setTimeout","location","reload","React","Component","Boolean","hostname","match","ReactDOM","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8698afe9.chunk.js","sourcesContent":["import React from 'react';\nimport * as THREE from \"three\";\n\nclass App extends React.Component {\n  constructor() {\n    super()\n\n    this.state={\n      cubes: []\n    }\n\n    this.clickLocator = this.clickLocator.bind(this)\n    this.cubeIncludes = this.cubeIncludes.bind(this)\n    this.directionChanger = this.directionChanger.bind(this)\n    document.addEventListener('click', (event) => this.clickLocator(event))\n  }\n\n  componentDidMount() {\n\n    var scene = new THREE.Scene();\n\n    //1: field of view (fov): the extend of the scene seen on the display at any given time\n    //2: aspect ratio: usually width/height to avoid distortion. default is 2. \n    //3 + 4: near + far clipping planes: where is too close or too far to see\n    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );\n    //(x, y, z)\n    camera.position.set( 0, 0, 0 );\n    camera.lookAt( 0, 0, 0 );\n\n    //sets how much of the screen this will take up. Can be used to reduce resolution\n    //WebGLRenderer is used for most current browsers. \n    var renderer = new THREE.WebGLRenderer();\n    renderer.setSize( window.innerWidth, window.innerHeight );\n    document.body.appendChild( renderer.domElement );\n\n    let geometry = new THREE.BoxGeometry( 1, 1, 1 );\n    camera.position.z = 5;\n\n    //add light to the scene\n    const color = 0xFFFFFF;\n    const intensity = 1;\n    const light = new THREE.DirectionalLight(color, intensity);\n    light.position.set(-1, 2, 4);\n    scene.add(light);\n    \n    //make the cubes\n    function makeInstance(geometry, color, x, y, name) {\n      const material = new THREE.MeshPhongMaterial({color});\n      const cube = new THREE.Mesh(geometry, material);\n      scene.add(cube);\n      cube.position.x = x; \n      cube.position.y = y;\n      cube.name = name;\n      cube.xDifferentiation = 0.01\n      cube.yDifferentiation = 0.01\n      return cube;  \n    }\n\n    const cubeA = makeInstance(geometry, 0x44aa88, 0, 0, 'greenish');\n    const cubeB = makeInstance(geometry, 0x8844aa, -2, -2, 'purple');\n    const cubeC = makeInstance(geometry, 0xaa8844,  1, 1, 'yellow');\n    \n    const cubes = [\n      cubeA,\n      cubeB,\n      cubeC,\n    ];\n\n    this.setState({cubes: [...cubes]})\n    \n    // spin\n    let animate = function () {\n      requestAnimationFrame( animate );\n      cubes.forEach((cube, i) => {\n        let additional = (i+1)*0.01\n        cube.rotation.x += additional;\n        cube.rotation.y += additional;\n\n      })\n      renderer.render( scene, camera );\n    };\n    animate();\n    \n\n    //travel\n    let travel = function () {\n      requestAnimationFrame( travel );\n      cubes.forEach((cube) => {\n          if (cube.position.x > 9 || cube.position.x < -9 || cube.position.y > 5 || cube.position.y < -5) {\n            renderer.setClearColor(0xFF0000)\n            // eslint-disable-next-line no-restricted-globals\n            setTimeout(() => {location.reload()}, 2000)\n          }\n          cube.position.x += cube.xDifferentiation;\n          cube.position.y -= cube.yDifferentiation;\n      })\n      renderer.render( scene, camera );\n    };\n    travel();\n  }\n\n\n  //access location of click\n  clickLocator = (event) => {\n    let [clickedCube]= this.state.cubes.filter(cube => this.cubeIncludes(cube, event.pageX, event.pageY));\n    if (clickedCube) {\n      this.directionChanger(clickedCube)\n    }\n    if (this.state.lost) {\n      console.log(event)\n    }\n  }\n\n  //does click fall onto a cube\n  cubeIncludes = function(cube, clickX, clickY) {\n    let cubeX = {\n      xPosition: cube.position.x * 80 + 720,\n      xMin: cube.position.x * 80 + 651,\n      xMax: cube.position.x * 80 + 789,\n    };\n  \n    let cubeY = {\n      yPosition: cube.position.y * 87.7 + (window.innerHeight/2),\n      yMin: -1*cube.position.y * 87.7 + (window.innerHeight/2) - 69,\n      yMax: -1*cube.position.y * 87.7 + (window.innerHeight/2) + 69,\n    };\n  \n    if (\n      clickX >= cubeX.xMin &&\n      clickX <= cubeX.xMax &&\n      clickY >= cubeY.yMin &&\n      clickY <= cubeY.yMax\n    ) {\n      return cube;\n    }\n  };\n\n  //if click falls on a cube change that cube's location\n  directionChanger = cube => {\n    cube.xDifferentiation = (0.01 + (Math.random()*0.01 - 0.005))*(-1)\n    cube.yDifferentiation = (0.01 + (Math.random()*0.01 - 0.005))*(-1)\n  }\n\n\n  render() {\n    return (\n      <div />\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}